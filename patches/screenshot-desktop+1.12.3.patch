diff --git a/node_modules/screenshot-desktop/lib/win32/index.js b/node_modules/screenshot-desktop/lib/win32/index.js
index de6b55d..77dc6d2 100644
--- a/node_modules/screenshot-desktop/lib/win32/index.js
+++ b/node_modules/screenshot-desktop/lib/win32/index.js
@@ -20,22 +20,42 @@ function windowsSnapshot (options = {}) {
 
     const displayChoice = displayName ? ` /d "${displayName}"` : ''
 
-    exec('"' + path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), 'screenCapture_1.3.2.bat') + '" "' + imgPath + '" ' + displayChoice, {
-      cwd: __dirname.replace('app.asar', 'app.asar.unpacked'),
-      windowsHide: true
-    }, (err, stdout) => {
-      if (err) {
-        return reject(err)
-      } else {
-        if (options.filename) {
-          resolve(imgPath)
+    if (options.windowId) {
+      console.log('"' + path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), 'screenCapture_1.3.2.bat') + '" "' + imgPath + '" ' + options.windowId)
+      exec('"' + path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), 'screenCapture_1.3.2.bat') + '" "' + imgPath + '" ' + options.windowId, {
+        cwd: __dirname.replace('app.asar', 'app.asar.unpacked'),
+        windowsHide: true
+      }, (err, stdout) => {
+        if (err) {
+          return reject(err)
         } else {
-          readAndUnlinkP(tmpPath)
-            .then(resolve)
-            .catch(reject)
+          if (options.filename) {
+            resolve(imgPath)
+          } else {
+            readAndUnlinkP(tmpPath)
+              .then(resolve)
+              .catch(reject)
+          }
         }
-      }
-    })
+      })
+    } else {
+      exec('"' + path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), 'screenCapture_1.3.2.bat') + '" "' + imgPath + '" ' + displayChoice, {
+        cwd: __dirname.replace('app.asar', 'app.asar.unpacked'),
+        windowsHide: true
+      }, (err, stdout) => {
+        if (err) {
+          return reject(err)
+        } else {
+          if (options.filename) {
+            resolve(imgPath)
+          } else {
+            readAndUnlinkP(tmpPath)
+              .then(resolve)
+              .catch(reject)
+          }
+        }
+      })
+    }
   })
 }
 
@@ -50,7 +70,7 @@ function parseDisplaysOutput (output) {
   return output.slice(index + match.length)
     .split('\n')
     .map(s => s.replace(/[\n\r]/g, ''))
-    .map(s => s.match(/(.*?);(.?\d+);(.?\d+);(.?\d+);(.?\d+);(.?\d*\.?\d+)/))
+    .map(s => s.match(/(.*?);(.?\d+);(.?\d+);(.?\d+);(.?\d+);(.?\d*[\.,]?\d+)/))
     .filter(s => s)
     .map(m => ({
       id: m[1],
@@ -59,7 +79,7 @@ function parseDisplaysOutput (output) {
       right: +m[3],
       bottom: +m[4],
       left: +m[5],
-      dpiScale: +m[6]
+      dpiScale: +m[6].replace(',', '.')
     }))
     .map(d => Object.assign(d, {
       height: d.bottom - d.top,
@@ -67,6 +87,22 @@ function parseDisplaysOutput (output) {
     }))
 }
 
+function parseWindowListOutput (output) {
+  return output
+    .split('\n')
+    .map(l => l.trim())
+    .filter(l => l[0] === 'w')
+    .map(l => l.substr(1))
+    .map(l => {
+      const index = l.indexOf(':')
+
+      return {
+        id: l.slice(0, index),
+        title: l.slice(index + 1)
+      }
+    })
+}
+
 function listDisplays () {
   return new Promise((resolve, reject) => {
     exec(
@@ -82,7 +118,23 @@ function listDisplays () {
   })
 }
 
+function listWindows () {
+  return new Promise((resolve, reject) => {
+    exec(
+      '"' + path.join(__dirname.replace('app.asar', 'app.asar.unpacked'), 'screenCapture_1.3.2.bat') + '" /listwindows', {
+        cwd: __dirname.replace('app.asar', 'app.asar.unpacked')
+      },
+      (err, stdout) => {
+        if (err) {
+          return reject(err)
+        }
+        resolve(parseWindowListOutput(stdout))
+      })
+  })
+}
+
 windowsSnapshot.listDisplays = listDisplays
+windowsSnapshot.listWindows = listWindows
 windowsSnapshot.availableDisplays = listDisplays
 windowsSnapshot.parseDisplaysOutput = parseDisplaysOutput
 windowsSnapshot.EXAMPLE_DISPLAYS_OUTPUT = EXAMPLE_DISPLAYS_OUTPUT
diff --git a/node_modules/screenshot-desktop/lib/win32/screenCapture_1.3.2.bat b/node_modules/screenshot-desktop/lib/win32/screenCapture_1.3.2.bat
index 10b83e7..f247064 100644
--- a/node_modules/screenshot-desktop/lib/win32/screenCapture_1.3.2.bat
+++ b/node_modules/screenshot-desktop/lib/win32/screenCapture_1.3.2.bat
@@ -23,8 +23,8 @@ endlocal & exit /b %errorlevel%
 
 */
 
-// reference
-// https://gallery.technet.microsoft.com/scriptcenter/eeff544a-f690-4f6b-a586-11eea6fc5eb8
+    // reference
+    // https://gallery.technet.microsoft.com/scriptcenter/eeff544a-f690-4f6b-a586-11eea6fc5eb8
 
 using System;
 using System.Runtime.InteropServices;
@@ -32,267 +32,266 @@ using System.Drawing;
 using System.Drawing.Imaging;
 using System.Collections.Generic;
 using Microsoft.VisualBasic;
+using System.Text;
+using System.Threading;
 
 
 
-/// Provides functions to capture the entire screen, or a particular window, and save it to a file.
+    /// Provides functions to capture the entire screen, or a particular window, and save it to a file.
 
-public class ScreenCapture
-{
-
-    static String deviceName = "";
-    static Image capturedImage = null;
+    public class ScreenCapture
+    {
 
-    /// Creates an Image object containing a screen shot the active window
+        static String deviceName = "";
+        static Image capturedImage = null;
 
-    public Image CaptureActiveWindow()
-    {
-        return CaptureWindow(User32.GetForegroundWindow());
-    }
 
-    /// Creates an Image object containing a screen shot of the entire desktop
+        /// Creates an Image object containing a screen shot of the entire desktop
+        public Image CaptureScreen()
+        {
+            if (!deviceName.Equals(""))
+            {
+                CaptureSpecificWindow();
+                if (capturedImage != null)
+                {
+                    return capturedImage;
+                }
+                Console.WriteLine("Unable to capture image... using main display");
+            }
+            return CaptureWindow(User32.GetDesktopWindow());
+        }
 
-    public Image CaptureScreen()
-    {
-        if (!deviceName.Equals(""))
+        /// Creates an Image object containing a screen shot of a specific window
+        public Image CaptureWindow(IntPtr handle)
         {
-            CaptureSpecificWindow();
-            if (capturedImage != null)
+            // if we get passed 0, we screenshot the foreground window, whatever it might be
+            if(handle != IntPtr.Zero)
+            {
+                User32.ShowWindow(handle, 5);
+                User32.SetForegroundWindow(handle);
+                Thread.Sleep(100); // small delay so the window has a chance to actually be drawn on the screen (during testing some issues emerged with certain windows)
+            }
+            else
             {
-                return capturedImage;
+                handle = User32.GetForegroundWindow();
             }
-            Console.WriteLine("Unable to capture image... using main display");
+            
+            // get te hDC of the target window
+            IntPtr hdcSrc = User32.GetWindowDC(handle);
+            if (hdcSrc == IntPtr.Zero) return null;
+            // get the size
+            RECT windowRect = DWMAPI.GetWindowRectangle(handle);
+
+            Image img = CaptureWindowFromDC(handle, hdcSrc, windowRect);
+            User32.ReleaseDC(handle, hdcSrc);
+            return img;
         }
-        return CaptureWindow(User32.GetDesktopWindow());
-    }
+        private static Image CaptureWindowFromDC(IntPtr handle, IntPtr hdcSrc, RECT windowRect)
+        {
+            // get the size
+            int width = windowRect.right - windowRect.left;
+            int height = windowRect.bottom - windowRect.top;
 
-    /// Creates an Image object containing a screen shot of a specific window
 
-    private Image CaptureWindow(IntPtr handle)
-    {
-        // get te hDC of the target window
-        IntPtr hdcSrc = User32.GetWindowDC(handle);
-        // get the size
-        User32.RECT windowRect = new User32.RECT();
-        User32.GetWindowRect(handle, ref windowRect);
-
-        Image img = CaptureWindowFromDC(handle, hdcSrc, windowRect);
-        User32.ReleaseDC(handle, hdcSrc);
-        return img;
-    }
-    private static Image CaptureWindowFromDC(IntPtr handle, IntPtr hdcSrc, User32.RECT windowRect){
-        // get the size
-        int width = windowRect.right - windowRect.left;
-        int height = windowRect.bottom - windowRect.top;
-        // create a device context we can copy to
-        IntPtr hdcDest = GDI32.CreateCompatibleDC(hdcSrc);
-        // create a bitmap we can copy it to,
-        // using GetDeviceCaps to get the width/height
-        IntPtr hBitmap = GDI32.CreateCompatibleBitmap(hdcSrc, width, height);
-        // select the bitmap object
-        IntPtr hOld = GDI32.SelectObject(hdcDest, hBitmap);
-        // bitblt over
-        GDI32.BitBlt(hdcDest, 0, 0, width, height, hdcSrc, windowRect.left, windowRect.top, GDI32.SRCCOPY);
-        // restore selection
-        GDI32.SelectObject(hdcDest, hOld);
-        // clean up
-        GDI32.DeleteDC(hdcDest);
-        // get a .NET image object for it
-        Image img = Image.FromHbitmap(hBitmap);
-        // free up the Bitmap object
-        GDI32.DeleteObject(hBitmap);
-        return img;
-    }
+            // create a device context we can copy to
+            IntPtr hdcDest = GDI32.CreateCompatibleDC(hdcSrc);
+            // create a bitmap we can copy it to,
+            // using GetDeviceCaps to get the width/height
+            IntPtr hBitmap = GDI32.CreateCompatibleBitmap(hdcSrc, width, height);
+            // select the bitmap object
+            IntPtr hOld = GDI32.SelectObject(hdcDest, hBitmap);
+            // bitblt over
 
-    public void CaptureActiveWindowToFile(string filename, ImageFormat format)
-    {
-        Image img = CaptureActiveWindow();
-        img.Save(filename, format);
-    }
+            IntPtr desktopDC = User32.GetWindowDC(User32.GetDesktopWindow());
             
-    public void CaptureScreenToFile(string filename, ImageFormat format)
-    {
-        Image img = CaptureScreen();
-        img.Save(filename, format);
-    }
 
-    static bool fullscreen = true;
-    static String file = "screenshot.bmp";
-    static System.Drawing.Imaging.ImageFormat format = System.Drawing.Imaging.ImageFormat.Bmp;
-    static String windowTitle = "";
-    static List<MonitorInfoWithHandle> _monitorInfos;
+            // This only works if hdcSrc is the desktop-window
+            GDI32.BitBlt(hdcDest, 0, 0, width, height, desktopDC, windowRect.left, windowRect.top, GDI32.SRCCOPY);
 
-    static void parseArguments()
-    {
-        String[] arguments = Environment.GetCommandLineArgs();
-        if (arguments.Length == 1)
-        {
-            printHelp();
-            Environment.Exit(0);
-        }
-        if (arguments[1].ToLower().Equals("/h") || arguments[1].ToLower().Equals("/help"))
-        {
-            printHelp();
-            Environment.Exit(0);
-        }
-        if (arguments[1].ToLower().Equals("/l") || arguments[1].ToLower().Equals("/list"))
-        {
-            PrintMonitorInfo();
-            Environment.Exit(0);
-        }
+            User32.ReleaseDC(User32.GetDesktopWindow(), desktopDC);
 
-        file = arguments[1];
-        Dictionary<String, System.Drawing.Imaging.ImageFormat> formats =
-        new Dictionary<String, System.Drawing.Imaging.ImageFormat>();
 
-        formats.Add("bmp", System.Drawing.Imaging.ImageFormat.Bmp);
-        formats.Add("emf", System.Drawing.Imaging.ImageFormat.Emf);
-        formats.Add("exif", System.Drawing.Imaging.ImageFormat.Exif);
-        formats.Add("jpg", System.Drawing.Imaging.ImageFormat.Jpeg);
-        formats.Add("jpeg", System.Drawing.Imaging.ImageFormat.Jpeg);
-        formats.Add("gif", System.Drawing.Imaging.ImageFormat.Gif);
-        formats.Add("png", System.Drawing.Imaging.ImageFormat.Png);
-        formats.Add("tiff", System.Drawing.Imaging.ImageFormat.Tiff);
-        formats.Add("wmf", System.Drawing.Imaging.ImageFormat.Wmf);
+            // This captures the window directly
+            //GDI32.BitBlt(hdcDest, 0, 0, width, height, hdcSrc, 0, 0, GDI32.SRCCOPY);
 
 
-        String ext = "";
-        if (file.LastIndexOf('.') > -1)
-        {
-            ext = file.ToLower().Substring(file.LastIndexOf('.') + 1, file.Length - file.LastIndexOf('.') - 1);
-        }
-        else
-        {
-            Console.WriteLine("Invalid file name - no extension");
-            Environment.Exit(7);
+            // restore selection
+            GDI32.SelectObject(hdcDest, hOld);
+            // clean up
+            GDI32.DeleteDC(hdcDest);
+            // get a .NET image object for it
+            Image img = Image.FromHbitmap(hBitmap);
+            // free up the Bitmap object
+            GDI32.DeleteObject(hBitmap);
+            return img;
         }
 
-        try
+        public void CaptureWindowToFile(IntPtr handle, string filename, ImageFormat format)
         {
-            format = formats[ext];
+            Image img = CaptureWindow(handle);
+            img.Save(filename, format);
         }
-        catch (Exception e)
+
+        public void CaptureScreenToFile(string filename, ImageFormat format)
         {
-            Console.WriteLine("Probably wrong file format:" + ext);
-            Console.WriteLine(e.ToString());
-            Environment.Exit(8);
+            Image img = CaptureScreen();
+            img.Save(filename, format);
         }
 
-        if (arguments.Length <= 2){
-            return;
-        }
+        static bool fullscreen = true;
+        static String file = "screenshot.bmp";
+        static System.Drawing.Imaging.ImageFormat format = System.Drawing.Imaging.ImageFormat.Bmp;
+        static String windowId = "";
+        static List<MonitorInfoWithHandle> _monitorInfos;
 
-        if (arguments[2].ToLower().Equals("/d") || arguments[2].ToLower().Equals("/display")){
-            if (arguments.Length == 2) {
-                Console.WriteLine("Must specify a display if passing /display");
-                Environment.Exit(9);
-            }
-            deviceName = arguments[3];
-        }
-        else if (arguments.Length > 2)
+        static void parseArguments()
         {
-            windowTitle = arguments[2];
-            fullscreen = false;
-        }
+            String[] arguments = Environment.GetCommandLineArgs();
+            if (arguments.Length == 1)
+            {
+                printHelp();
+                Environment.Exit(0);
+            }
+            if (arguments[1].ToLower().Equals("/h") || arguments[1].ToLower().Equals("/help"))
+            {
+                printHelp();
+                Environment.Exit(0);
+            }
+            if (arguments[1].ToLower().Equals("/l") || arguments[1].ToLower().Equals("/list"))
+            {
+                PrintMonitorInfo();
+                Environment.Exit(0);
+            }
+            if (arguments[1].ToLower().Equals("/o") || arguments[1].ToLower().Equals("/listwindows"))
+            {
+                PrintWindowList();
+                Environment.Exit(0);
+            }
 
-    }
+            file = arguments[1];
+            Dictionary<String, System.Drawing.Imaging.ImageFormat> formats =
+            new Dictionary<String, System.Drawing.Imaging.ImageFormat>();
 
-    static void printHelp()
-    {
-        //clears the extension from the script name
-        String scriptName = Environment.GetCommandLineArgs()[0];
-        scriptName = scriptName.Substring(0, scriptName.Length);
-        Console.WriteLine(scriptName + " captures the screen or the active window and saves it to a file.");
-        Console.WriteLine("");
-        Console.WriteLine("Usage:");
-        Console.WriteLine(" " + scriptName + " filename  [WindowTitle]");
-        Console.WriteLine("");
-        Console.WriteLine("filename - the file where the screen capture will be saved");
-        Console.WriteLine("     allowed file extensions are - Bmp,Emf,Exif,Gif,Icon,Jpeg,Png,Tiff,Wmf.");
-        Console.WriteLine("WindowTitle - instead of capture whole screen you can point to a window ");
-        Console.WriteLine("     with a title which will put on focus and captuted.");
-        Console.WriteLine("     For WindowTitle you can pass only the first few characters.");
-        Console.WriteLine("     If don't want to change the current active window pass only \"\"");
-        Console.WriteLine("");
-        Console.WriteLine(" " + scriptName + " (/l | /list)");
-        Console.WriteLine("");
-        Console.WriteLine("List the available displays");
-        Console.WriteLine("");
-        Console.WriteLine(" " + scriptName + " filename  (/d | /display) displayName");
-        Console.WriteLine("");
-        Console.WriteLine("filename - as above");
-        Console.WriteLine("displayName - a display name optained from running the script with /list");
-    }
+            formats.Add("bmp", System.Drawing.Imaging.ImageFormat.Bmp);
+            formats.Add("emf", System.Drawing.Imaging.ImageFormat.Emf);
+            formats.Add("exif", System.Drawing.Imaging.ImageFormat.Exif);
+            formats.Add("jpg", System.Drawing.Imaging.ImageFormat.Jpeg);
+            formats.Add("jpeg", System.Drawing.Imaging.ImageFormat.Jpeg);
+            formats.Add("gif", System.Drawing.Imaging.ImageFormat.Gif);
+            formats.Add("png", System.Drawing.Imaging.ImageFormat.Png);
+            formats.Add("tiff", System.Drawing.Imaging.ImageFormat.Tiff);
+            formats.Add("wmf", System.Drawing.Imaging.ImageFormat.Wmf);
 
-    public static void Main()
-    {
-        parseArguments();
-        ScreenCapture sc = new ScreenCapture();
-        if (!fullscreen && !windowTitle.Equals(""))
-        {
-            try
+
+            String ext = "";
+            if (file.LastIndexOf('.') > -1)
             {
+                ext = file.ToLower().Substring(file.LastIndexOf('.') + 1, file.Length - file.LastIndexOf('.') - 1);
+            }
+            else
+            {
+                Console.WriteLine("Invalid file name - no extension");
+                Environment.Exit(7);
+            }
 
-                Interaction.AppActivate(windowTitle);
-                Console.WriteLine("setting " + windowTitle + " on focus");
+            try
+            {
+                format = formats[ext];
             }
             catch (Exception e)
             {
-                Console.WriteLine("Probably there's no window like " + windowTitle);
+                Console.WriteLine("Probably wrong file format:" + ext);
                 Console.WriteLine(e.ToString());
-                Environment.Exit(9);
+                Environment.Exit(8);
             }
 
+            if (arguments.Length <= 2)
+            {
+                return;
+            }
 
-        }
-        try
-        {
-            if (fullscreen)
+            if (arguments[2].ToLower().Equals("/d") || arguments[2].ToLower().Equals("/display"))
             {
-                Console.WriteLine("Taking a capture of the whole screen to " + file);
-                sc.CaptureScreenToFile(file, format);
+                if (arguments.Length == 2)
+                {
+                    Console.WriteLine("Must specify a display if passing /display");
+                    Environment.Exit(9);
+                }
+                deviceName = arguments[3];
             }
-            else
+            else if (arguments.Length > 2)
             {
-                Console.WriteLine("Taking a capture of the active window to " + file);
-                sc.CaptureActiveWindowToFile(file, format);
+                windowId = arguments[2];
+                fullscreen = false;
             }
+
         }
-        catch (Exception e)
+
+        static void printHelp()
         {
-            Console.WriteLine("Check if file path is valid " + file);
-            Console.WriteLine(e.ToString());
+            //clears the extension from the script name
+            String scriptName = Environment.GetCommandLineArgs()[0];
+            scriptName = scriptName.Substring(0, scriptName.Length);
+            Console.WriteLine(scriptName + " captures the screen or the active window and saves it to a file.");
+            Console.WriteLine("");
+            Console.WriteLine("Usage:");
+            Console.WriteLine(" " + scriptName + " filename  [WindowID]");
+            Console.WriteLine("");
+            Console.WriteLine("filename - the file where the screen capture will be saved");
+            Console.WriteLine("     allowed file extensions are - Bmp,Emf,Exif,Gif,Icon,Jpeg,Png,Tiff,Wmf.");
+            Console.WriteLine("WindowId - instead of capture whole screen you can point to a window ");
+            Console.WriteLine("");
+            Console.WriteLine(" " + scriptName + " (/l | /list)");
+            Console.WriteLine("");
+            Console.WriteLine("List the available displays");
+            Console.WriteLine("");
+            Console.WriteLine(" " + scriptName + " filename  (/d | /display) displayName");
+            Console.WriteLine("");
+            Console.WriteLine("filename - as above");
+            Console.WriteLine("displayName - a display name optained from running the script with /list");
         }
-    }
-
-    /// Helper class containing Gdi32 API functions
-
-    private class GDI32
-    {
 
-        public const int SRCCOPY = 0x00CC0020; // BitBlt dwRop parameter
-        [DllImport("gdi32.dll")]
-        public static extern bool BitBlt(IntPtr hObject, int nXDest, int nYDest,
-          int nWidth, int nHeight, IntPtr hObjectSource,
-          int nXSrc, int nYSrc, int dwRop);
-        [DllImport("gdi32.dll")]
-        public static extern IntPtr CreateCompatibleBitmap(IntPtr hDC, int nWidth,
-          int nHeight);
-        [DllImport("gdi32.dll")]
-        public static extern IntPtr CreateCompatibleDC(IntPtr hDC);
-        [DllImport("gdi32.dll")]
-        public static extern bool DeleteDC(IntPtr hDC);
-        [DllImport("gdi32.dll")]
-        public static extern bool DeleteObject(IntPtr hObject);
-        [DllImport("gdi32.dll")]
-        public static extern IntPtr SelectObject(IntPtr hDC, IntPtr hObject);
-    }
+        public static void Main()
+        {
+            parseArguments();
+            ScreenCapture sc = new ScreenCapture();
+            if (!fullscreen && windowId != "")
+            {
+                try
+                {
+                    IntPtr window = new IntPtr(Convert.ToInt32(windowId));
+                    sc.CaptureWindowToFile(window, file, format);
+                }
+                catch (Exception e)
+                {
+                    Console.WriteLine("Probably there's no window with this ID: " + windowId);
+                    Console.WriteLine(e.ToString());
+                    Environment.Exit(9);
+                }
+            } else
+            {
+                try
+                {
+                    Console.WriteLine("Taking a capture of the whole screen to " + file);
+                    sc.CaptureScreenToFile(file, format);
+                }
+                catch (Exception e)
+                {
+                    Console.WriteLine("Check if file path is valid " + file);
+                    Console.WriteLine(e.ToString());
+                }
+            }
+        }
 
+        /// Helper class containing Gdi32 API functions
 
-    /// Helper class containing User32 API functions
+        [StructLayout(LayoutKind.Sequential)]
+        public struct POINT
+        {
+            public long x;
+            public long y;
+        }
 
-    public class User32
-    {
         [StructLayout(LayoutKind.Sequential)]
         public struct RECT
         {
@@ -302,107 +301,287 @@ public class ScreenCapture
             public int bottom;
         }
 
-        [DllImport("user32.dll")]
-        public static extern IntPtr GetDC(IntPtr hWnd);
-        [DllImport("user32.dll")]
-        public static extern IntPtr GetDesktopWindow();
-        [DllImport("user32.dll")]
-        public static extern IntPtr GetWindowDC(IntPtr hWnd);
-        [DllImport("user32.dll")]
-        public static extern IntPtr ReleaseDC(IntPtr hWnd, IntPtr hDC);
-        [DllImport("user32.dll")]
-        public static extern IntPtr GetWindowRect(IntPtr hWnd, ref RECT rect);
-        [DllImport("user32.dll")]
-        public static extern IntPtr GetForegroundWindow();
-
-       [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
-       public struct MONITORINFOEX
-       {
-           public uint size;
-           public RECT Monitor;
-           public RECT WorkArea;
-           public uint Flags;
-           [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
-           public string DeviceName;
-       }
-
-       [DllImport("user32.dll", CharSet = CharSet.Unicode)]
-       public static extern bool GetMonitorInfo(IntPtr hMonitor, ref MONITORINFOEX lpmi);
-
-       public delegate bool MonitorEnumDelegate(IntPtr hMonitor, IntPtr hdcMonitor, ref RECT lprcMonitor, IntPtr dwData);
-
-       [DllImport("user32.dll")]
-       public static extern bool EnumDisplayMonitors(IntPtr hdc, IntPtr lprcClip, MonitorEnumDelegate lpfnEnum, IntPtr dwData);
-    }
+        private class DWMAPI
+        {
+            [Flags]
+            private enum DwmWindowAttribute : uint
+            {
+                DWMWA_NCRENDERING_ENABLED = 1,
+                DWMWA_NCRENDERING_POLICY,
+                DWMWA_TRANSITIONS_FORCEDISABLED,
+                DWMWA_ALLOW_NCPAINT,
+                DWMWA_CAPTION_BUTTON_BOUNDS,
+                DWMWA_NONCLIENT_RTL_LAYOUT,
+                DWMWA_FORCE_ICONIC_REPRESENTATION,
+                DWMWA_FLIP3D_POLICY,
+                DWMWA_EXTENDED_FRAME_BOUNDS,
+                DWMWA_HAS_ICONIC_BITMAP,
+                DWMWA_DISALLOW_PEEK,
+                DWMWA_EXCLUDED_FROM_PEEK,
+                DWMWA_CLOAK,
+                DWMWA_CLOAKED,
+                DWMWA_FREEZE_REPRESENTATION,
+                DWMWA_LAST
+            }
 
-    public class Shcore
-    {
-       [DllImport("Shcore.dll")]
-       public static extern IntPtr GetDpiForMonitor(IntPtr hMonitor, int dpiType, out uint dpiX, out uint dpiY);
-    }
+            [DllImport("dwmapi.dll")]
+            public static extern int DwmGetWindowAttribute(IntPtr hWnd, int dwAttribute, out RECT pvAttribute, int cbAttribute);
 
-    private class MonitorInfoWithHandle
-    {
-        public IntPtr MonitorHandle { get; private set; }
-        public User32.MONITORINFOEX MonitorInfo { get; private set; }
-        public float DpiScale { get; private set; }
-        public MonitorInfoWithHandle(IntPtr monitorHandle, User32.MONITORINFOEX monitorInfo, float dpiScale)
+            public static RECT GetWindowRectangle(IntPtr hWnd)
+            {
+                RECT rect;
+
+                int size = Marshal.SizeOf(typeof(RECT));
+                DwmGetWindowAttribute(hWnd, (int)DwmWindowAttribute.DWMWA_EXTENDED_FRAME_BOUNDS, out rect, size);
+
+                return rect;
+            }
+        }
+
+        private class GDI32
         {
-            MonitorHandle = monitorHandle;
-            MonitorInfo = monitorInfo;
-            DpiScale = dpiScale;
+            
+
+            public const int SRCCOPY = 0x00CC0020; // BitBlt dwRop parameter
+            [DllImport("gdi32.dll")]
+            public static extern bool BitBlt(IntPtr hObject, int nXDest, int nYDest,
+              int nWidth, int nHeight, IntPtr hObjectSource,
+              int nXSrc, int nYSrc, int dwRop);
+            [DllImport("gdi32.dll")]
+            public static extern IntPtr CreateCompatibleBitmap(IntPtr hDC, int nWidth,
+              int nHeight);
+            [DllImport("gdi32.dll")]
+            public static extern IntPtr CreateCompatibleDC(IntPtr hDC);
+            [DllImport("gdi32.dll")]
+            public static extern bool DeleteDC(IntPtr hDC);
+            [DllImport("gdi32.dll")]
+            public static extern bool DeleteObject(IntPtr hObject);
+            [DllImport("gdi32.dll")]
+            public static extern IntPtr SelectObject(IntPtr hDC, IntPtr hObject);
+            
         }
-    }
-    private static bool MonitorEnum(IntPtr hMonitor, IntPtr hdcMonitor, ref User32.RECT lprcMonitor, IntPtr dwData)
-    {
-        var mi = new User32.MONITORINFOEX();
-        mi.size = (uint)Marshal.SizeOf(mi);
-        User32.GetMonitorInfo(hMonitor, ref mi);
-        uint dpiX, dpiY;
-        Shcore.GetDpiForMonitor(hMonitor, 0, out dpiX, out dpiY);
-        float dpiScale = ((float) dpiX) / 96;
-
-        _monitorInfos.Add(new MonitorInfoWithHandle(hMonitor, mi, dpiScale));
-        return true;
-    }
-    private static bool CaptureMonitorEnum(IntPtr hMonitor, IntPtr hdcMonitor, ref User32.RECT lprcMonitor, IntPtr dwData)
-    {
-        var mi = new User32.MONITORINFOEX();
-        mi.size = (uint)Marshal.SizeOf(mi);
-        User32.GetMonitorInfo(hMonitor, ref mi);
-        if (mi.DeviceName.ToLower().Equals(deviceName.ToLower())) {
-            Console.WriteLine("hMonitor is {0}, hdcMonitor is {1}", hMonitor, hdcMonitor);
-            capturedImage = CaptureWindowFromDC(hMonitor, hdcMonitor, lprcMonitor);
+
+
+        /// Helper class containing User32 API functions
+
+        public class User32
+        {
+            
+
+            [DllImport("user32.dll")]
+            public static extern IntPtr GetDC(IntPtr hWnd);
+            [DllImport("user32.dll")]
+            public static extern IntPtr GetDesktopWindow();
+            [DllImport("user32.dll")]
+            public static extern IntPtr GetWindowDC(IntPtr hWnd);
+            [DllImport("user32.dll")]
+            public static extern IntPtr ReleaseDC(IntPtr hWnd, IntPtr hDC);
+            [DllImport("user32.dll")]
+            public static extern IntPtr GetWindowRect(IntPtr hWnd, ref RECT rect);
+            [DllImport("user32.dll")]
+            public static extern IntPtr GetForegroundWindow();
+            [DllImport("user32.dll")]
+            private static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);
+            [DllImport("user32.dll")]
+            private static extern bool IsWindowVisible(IntPtr hWnd);
+            [DllImport("user32.dll")]
+            [return: MarshalAs(UnmanagedType.Bool)]
+            static extern bool IsIconic(IntPtr hWnd);
+            [DllImport("user32.dll", SetLastError = true)]
+            public static extern System.UInt32 GetWindowLong(IntPtr hWnd, int nIndex);
+
+            [DllImport("user32.dll")]
+            public static extern IntPtr SetForegroundWindow(IntPtr hWnd);
+
+            [DllImport("user32.dll")]
+            public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
+
+
+            [DllImport("user32.dll")]
+            static extern IntPtr GetShellWindow();
+
+
+            [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
+            static extern int GetWindowTextLength(IntPtr hWnd);
+            [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
+            static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);
+
+            // Delegate to enumerate windows
+            public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
+
+            /// <summary> Lists all windows</summary>
+            public static IEnumerable<IntPtr> ListWindows()
+            {
+                var shellWindow = GetShellWindow();
+                List<IntPtr> windows = new List<IntPtr>();
+
+                EnumWindows(delegate (IntPtr wnd, IntPtr param)
+                {
+                    if (wnd == shellWindow)
+                        return true;
+
+                    if (!IsWindowVisible(wnd))
+                        return true;
+
+                    if (IsIconic(wnd))
+                        return true;
+
+                    if (HasSomeExtendedWindowsStyles(wnd))
+                        return true;
+
+                    var length = GetWindowTextLength(wnd);
+
+                    if (length == 0)
+                        return true;
+
+                    var builder = new StringBuilder(length);
+
+                    GetWindowText(wnd, builder, length + 1);
+                    windows.Add(wnd);
+
+                    return true;
+                }, IntPtr.Zero);
+
+                return windows;
+            }
+
+            public static IDictionary<IntPtr, string> GetOpenWindows()
+            {
+                IntPtr shellWindow = GetShellWindow();
+                Dictionary<IntPtr, string> windows = new Dictionary<IntPtr, string>();
+
+                EnumWindows(delegate (IntPtr hWnd, IntPtr param)
+                { 
+                    if (hWnd == shellWindow) return true;
+                    if (!IsWindowVisible(hWnd)) return true;
+
+                    int length = GetWindowTextLength(hWnd);
+                    if (length == 0) return true;
+
+                    StringBuilder builder = new StringBuilder(length);
+                    GetWindowText(hWnd, builder, length + 1);
+
+                    windows[hWnd] = builder.ToString();
+
+                    return true;
+                }, IntPtr.Zero);
+
+                return windows;
+            }
+
+            static bool HasSomeExtendedWindowsStyles(IntPtr hwnd)
+            {
+                const int GWL_EXSTYLE = -20;
+                const uint WS_EX_TOOLWINDOW = 0x00000080U;
+
+                uint i = GetWindowLong(hwnd, GWL_EXSTYLE);
+                if ((i & (WS_EX_TOOLWINDOW)) != 0)
+                {
+                    return true;
+                }
+
+                return false;
+            }
+
+
+            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
+            public struct MONITORINFOEX
+            {
+                public uint size;
+                public RECT Monitor;
+                public RECT WorkArea;
+                public uint Flags;
+                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
+                public string DeviceName;
+            }
+
+            [DllImport("user32.dll", CharSet = CharSet.Unicode)]
+            public static extern bool GetMonitorInfo(IntPtr hMonitor, ref MONITORINFOEX lpmi);
+
+            public delegate bool MonitorEnumDelegate(IntPtr hMonitor, IntPtr hdcMonitor, ref RECT lprcMonitor, IntPtr dwData);
+
+            [DllImport("user32.dll")]
+            public static extern bool EnumDisplayMonitors(IntPtr hdc, IntPtr lprcClip, MonitorEnumDelegate lpfnEnum, IntPtr dwData);
         }
-        return true;
-    }
-    public static void CaptureSpecificWindow()
-    {
-        IntPtr hdc = User32.GetDC(IntPtr.Zero);
-        User32.EnumDisplayMonitors(hdc, IntPtr.Zero, CaptureMonitorEnum, IntPtr.Zero);
-        User32.ReleaseDC(IntPtr.Zero, hdc);
-    }
-    private static List<MonitorInfoWithHandle> GetMonitors()
-    {
-        _monitorInfos = new List<MonitorInfoWithHandle>();
 
-        User32.EnumDisplayMonitors(IntPtr.Zero, IntPtr.Zero, MonitorEnum, IntPtr.Zero);
+        public class Shcore
+        {
+            [DllImport("Shcore.dll")]
+            public static extern IntPtr GetDpiForMonitor(IntPtr hMonitor, int dpiType, out uint dpiX, out uint dpiY);
+        }
 
-        return _monitorInfos;
-    }
+        private class MonitorInfoWithHandle
+        {
+            public IntPtr MonitorHandle { get; private set; }
+            public User32.MONITORINFOEX MonitorInfo { get; private set; }
+            public float DpiScale { get; private set; }
+            public MonitorInfoWithHandle(IntPtr monitorHandle, User32.MONITORINFOEX monitorInfo, float dpiScale)
+            {
+                MonitorHandle = monitorHandle;
+                MonitorInfo = monitorInfo;
+                DpiScale = dpiScale;
+            }
+        }
+        private static bool MonitorEnum(IntPtr hMonitor, IntPtr hdcMonitor, ref RECT lprcMonitor, IntPtr dwData)
+        {
+            var mi = new User32.MONITORINFOEX();
+            mi.size = (uint)Marshal.SizeOf(mi);
+            User32.GetMonitorInfo(hMonitor, ref mi);
+            uint dpiX, dpiY;
+            Shcore.GetDpiForMonitor(hMonitor, 0, out dpiX, out dpiY);
+            float dpiScale = ((float)dpiX) / 96;
+
+            _monitorInfos.Add(new MonitorInfoWithHandle(hMonitor, mi, dpiScale));
+            return true;
+        }
+        private static bool CaptureMonitorEnum(IntPtr hMonitor, IntPtr hdcMonitor, ref RECT lprcMonitor, IntPtr dwData)
+        {
+            var mi = new User32.MONITORINFOEX();
+            mi.size = (uint)Marshal.SizeOf(mi);
+            User32.GetMonitorInfo(hMonitor, ref mi);
+            if (mi.DeviceName.ToLower().Equals(deviceName.ToLower()))
+            {
+                Console.WriteLine("hMonitor is {0}, hdcMonitor is {1}", hMonitor, hdcMonitor);
+                capturedImage = CaptureWindowFromDC(hMonitor, hdcMonitor, lprcMonitor);
+            }
+            return true;
+        }
+        public static void CaptureSpecificWindow()
+        {
+            IntPtr hdc = User32.GetDC(IntPtr.Zero);
+            User32.EnumDisplayMonitors(hdc, IntPtr.Zero, CaptureMonitorEnum, IntPtr.Zero);
+            User32.ReleaseDC(IntPtr.Zero, hdc);
+        }
+        private static List<MonitorInfoWithHandle> GetMonitors()
+        {
+            _monitorInfos = new List<MonitorInfoWithHandle>();
 
-    public static void PrintMonitorInfo()
-    {
-        var mis = GetMonitors();
-        foreach (var mi in mis)
+            User32.EnumDisplayMonitors(IntPtr.Zero, IntPtr.Zero, MonitorEnum, IntPtr.Zero);
+
+            return _monitorInfos;
+        }
+
+        public static void PrintMonitorInfo()
+        {
+            var mis = GetMonitors();
+            foreach (var mi in mis)
+            {
+                Console.WriteLine("{0};{1};{2};{3};{4};{5}",
+                    mi.MonitorInfo.DeviceName,
+                    mi.MonitorInfo.Monitor.top,
+                    mi.MonitorInfo.Monitor.right,
+                    mi.MonitorInfo.Monitor.bottom,
+                    mi.MonitorInfo.Monitor.left,
+                    mi.DpiScale);
+            }
+        }
+
+        public static void PrintWindowList()
         {
-            Console.WriteLine("{0};{1};{2};{3};{4};{5}",
-                mi.MonitorInfo.DeviceName,
-                mi.MonitorInfo.Monitor.top,
-                mi.MonitorInfo.Monitor.right,
-                mi.MonitorInfo.Monitor.bottom,
-                mi.MonitorInfo.Monitor.left,
-                mi.DpiScale);
+            var windows = User32.GetOpenWindows();
+            foreach(var window in windows)
+            {
+                Console.WriteLine("w{0}:{1}", window.Key, window.Value);
+            }
         }
     }
-}
